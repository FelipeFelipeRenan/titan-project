server:
  port: 8081
  address: 0.0.0.0

spring:
  application:
    name: titan-ledger-core
  datasource:
    url: jdbc:postgresql://localhost:5432/titan_ledger
    username: titan_user
    password: titan_password
    driver-class-name: org.postgresql.Driver
  jpa:
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    hibernate:
      ddl-auto: validate
  flyway:
    enabled: true
    baseline-on-migrate: true
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: titan-ledger-group
      auto-offset-reset: earliest
  data:
    redis:
      host: redis
      port: 6379

management:
  endpoints:
    web:
      exposure:
        # Habilita o endpoint que o Prometheus vai ler
        include: health,info,metrics,prometheus
  
  # CONFIGURAÇÃO DO OPENTELEMETRY (OTLP) -> JAEGER management.opentelemetry.tracing.export.otlp.endpoint
  otlp:
    tracing:
      endpoint: http://jeager:4318/v1/traces # Endpoint HTTP do Jaeger
    metrics:
      export:
        enabled: false
  
  tracing:
    sampling:
      probability: 1.0 # 100% das requests
    
    # O Spring Boot 3/4 usa OTLP por padrão quando o starter está presente.
    # Mas é bom garantir que o exportador esteja ativo.
    exporter:
      zipkin:
        enabled: false # Garante que Zipkin está desligado
      otlp:
        enabled: true

  metrics:
    tags:
      application: ${spring.application.name} # Etiqueta todas as métricas com o nome do app
    distribution:
      percentiles-histogram:
        http.server.requests: true # Gera histogramas para vermos p95, p99 de latência
logging:
  level:
    root: INFO
    # Debug para ver se o autoconfig do OTel está rodando
    io.opentelemetry.exporter: DEBUG
    org.springframework.boot.autoconfigure.web.reactive.function.client: DEBUG
  pattern:
    level: '%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]'